#!/usr/bin/env python3
"""
A script to zip the logs produced by a series of competition matches.
"""

import re
import shutil
import argparse
import datetime
import tempfile
from pathlib import Path


def zip_folder(folder: Path, args: argparse.Namespace) -> None:
    tla = folder.name
    zip_name = f'team-{tla}'

    if args.suffix:
        zip_name += f'-{args.suffix}'
    if args.include_date:
        zip_name += f'-{datetime.date.today()}'

    shutil.make_archive(
        f'{args.output_dir / zip_name}',
        'zip',
        root_dir=folder,
        base_dir='.',
    )


def is_team_logs_folder(folder: Path) -> bool:
    # Options for detecting which folders are logs:
    # 1. everthing except recordings, matches
    # 2. folders w/ matching zip file names
    # 3. regex of folder name
    # 4. regex of folder contents names

    # Using option 3
    # folder names are three uppercase letters and an optional number
    if re.match(r'[A-Z]{3}[0-9]*$', folder.name):
        return True

    return False


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser()
    parser.add_argument(
        'archives_dir',
        help=(
            "The directory containing folders of the teams' robot logs, "
            "named for the teams' TLAs. This directory also contains the "
            "teams' robot code, as Zip archives and the match recordings."
        ),
        type=Path,
    )
    parser.add_argument(
        'output_dir',
        help=(
            "The directory to place the resulting log Zip archives. "
            "This should be an empty directory."
        ),
        type=Path,
    )
    parser.add_argument(
        '--suffix',
        help=(
            "Adds a suffix to the Zip archive name. "
            "Archive names follow the format: team-<TLA>-<suffix>-<date>.zip"
        ),
        default="",
    )
    parser.add_argument(
        '--no-date',
        help=(
            "Remove the date from the archive name."
        ),
        dest='include_date',
        action='store_false',
    )
    parser.add_argument(
        '--combined',
        help=(
            "Create a combined archive which contains all the other log archives. "
            "This is achieved by creating an archive of the contents of the output directory."
        ),
        action='store_true',
    )
    return parser.parse_args()


def main(args: argparse.Namespace) -> None:
    # make sure output directory exists
    args.output_dir.mkdir(exist_ok=True)

    for folder in args.archives_dir.iterdir():
        if not folder.is_dir():
            # skip files in the archive directory
            continue

        if not is_team_logs_folder(folder):
            # skip unrelated directories
            continue

        zip_folder(folder, args)

    if args.combined:
        # a temporary directory is used since the zip file
        # can't be created in the directory being archived
        with tempfile.TemporaryDirectory() as tmpdir_name:
            # create a combined archive
            tmpdir_path = Path(tmpdir_name)
            shutil.make_archive(
                str(tmpdir_path / 'combined'),
                'zip',
                root_dir=args.output_dir,
                base_dir='.',
            )
            shutil.copy(tmpdir_path / 'combined.zip', args.output_dir)


if __name__ == '__main__':
    main(parse_args())
