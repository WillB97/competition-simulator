#!/usr/bin/env python3
"""
A script to zip the logs produced by a series of competition matches.
"""

import re
import shutil
import argparse
import datetime
from typing import List
from pathlib import Path
from zipfile import ZipFile, ZIP_DEFLATED


def zip_folder(folder: Path, output_dir: Path, suffix: str, include_date: bool) -> str:
    tla = folder.name
    zip_name = f'team-{tla}{suffix}'

    if include_date:
        zip_name += f'-{datetime.date.today()}'

    shutil.make_archive(
        f'{output_dir / zip_name}',
        'zip',
        root_dir=folder,
        base_dir='.',
    )
    return f'{zip_name}.zip'


def is_team_logs_folder(folder: Path) -> bool:
    # Options for detecting which folders are logs:
    # 1. everthing except recordings, matches
    # 2. folders w/ matching zip file names
    # 3. regex of folder name
    # 4. regex of folder contents names

    # Using option 3
    # folder names are three uppercase letters and an optional number
    return bool(re.search(r'^[A-Z]{3}[0-9]?$', folder.name))


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser()
    parser.add_argument(
        'archives_dir',
        help=(
            "The directory containing folders of the teams' robot logs, "
            "named for the teams' TLAs. This directory also contains the "
            "teams' robot code, as Zip archives and the match recordings."
        ),
        type=Path,
    )
    parser.add_argument(
        'output_dir',
        help=(
            "The directory to place the resulting log Zip archives. "
            "This should be an empty directory."
        ),
        type=Path,
    )
    parser.add_argument(
        '--suffix',
        help=(
            "Adds a suffix to the Zip archive name. "
            "Archive names follow the format: team-<TLA>-<suffix>-<date>.zip"
        ),
        default="",
    )
    parser.add_argument(
        '--no-date',
        help=(
            "Remove the date from the archive name."
        ),
        dest='include_date',
        action='store_false',
    )
    parser.add_argument(
        '--with-combined',
        help=(
            "Create an additional combined archive which contains all the other log archives."
        ),
        action='store_true',
        dest='combined',
    )
    parser.add_argument(
        '--animations',
        help=(
            "Include the match animation files. "
            "'all' creates a separate archive of all matches, "
            "'separate' does the same as 'all' but excludes "
            "the archive from the combined archive."
        ),
        choices=('all', 'separate'),
        default=None,
    )
    return parser.parse_args()


def main(args: argparse.Namespace) -> None:
    # make sure output directory exists
    args.output_dir.mkdir(exist_ok=True)

    logs_archives: List[str] = []

    if args.suffix:
        suffix_str = f'-{args.suffix}'
    else:
        suffix_str = ""

    for folder in args.archives_dir.iterdir():
        if not folder.is_dir():
            # skip files in the archive directory
            continue

        if not is_team_logs_folder(folder):
            # skip unrelated directories
            continue

        logs_archives.append(zip_folder(
            folder,
            args.output_dir,
            suffix_str,
            args.include_date,
        ))

    if args.animations in ('all', 'separate'):
        with ZipFile(
            args.output_dir / f'animations{suffix_str}.zip',
            'w',
            compression=ZIP_DEFLATED,
        ) as zipfile:
            for rec_file in (args.archives_dir / 'recordings').iterdir():
                if rec_file.suffix == '.mp4':
                    continue
                zipfile.write(rec_file.resolve(), rec_file.name)

            # save animation textures
            for texture in (args.archives_dir / 'recordings' / 'textures').glob('**/*'):
                zipfile.write(
                    texture.resolve(),
                    texture.relative_to(args.archives_dir / 'recordings'),
                )

    if args.combined:
        with ZipFile(args.output_dir / f'combined{suffix_str}.zip', 'w') as zipfile:
            for logs_archive in logs_archives:
                zipfile.write(args.output_dir / logs_archive, logs_archive)

            if args.animations == 'all':
                animation_zip = f'animations{suffix_str}.zip'
                zipfile.write(args.output_dir / animation_zip, animation_zip)


if __name__ == '__main__':
    main(parse_args())
